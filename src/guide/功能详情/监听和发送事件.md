---
order: 1
---

# 监听和发送事件

:::tip
请务必先阅读[如何正确使用酒馆助手](/guide/基本用法/如何正确使用酒馆助手.md)
:::

扩展允许你设置当发生某种事件时运行想要的函数. 例如, 你也许想在玩家擅自更改你的世界书时警告玩家.

[点击查看对应类型定义文件 (可发给 AI 或 IDE 使用, 酒馆助手界面中提供了打包下载)](https://github.com/N0VI028/JS-Slash-Runner/blob/main/%40types/iframe/event.d.ts)

<CustomTOC />

## 事件列表

事件 `EventType` 可以是:

- `iframe_events` 中的 iframe 事件
- `tavern_events` 中近百种酒馆事件: 新开聊天、接收到消息、消息被修改、提示词被发送给 AI、世界书被修改……
- 自定义的字符串事件

具体请参考[事件列表](https://github.com/N0VI028/JS-Slash-Runner/blob/main/%40types/iframe/event.d.ts#L235)

## eventOn <Badge type="warning" text="🚫TavernHelper" />

监听事件, 当事件发生时自动运行函数.

如果 `listener` 已经在监听 `event_type`, 则调用本函数不会有任何效果.

当 `eventOn` 所在的前端界面/脚本关闭时, 监听将会自动卸载.

```ts
function eventOn<T extends EventType>(event_type: T, listener: ListenerType[T]): void;
```

### 参数

#### `event_type`

- **类型**: [`EventType`](./监听和发送事件#事件列表)
- **描述**: 要监听的事件

#### `listener`

- **类型**: `Function`
- **描述**: 要注册的函数

### 示例

:::code-group

```ts [监听消息接收]
// 监听消息接收并弹出 `'hello'`
eventOn(tavern_events.MESSAGE_RECEIVED, () => alert('hello'));
```

```ts [监听消息被修改]
// 酒馆事件 tavern_events.MESSAGE_UPDATED 会传递被更新的楼层 id
eventOn(tavern_events.MESSAGE_UPDATED, message_id => {
  alert(`你刚刚更新了第 ${message_id} 条聊天消息对吧😡`);
});
```

:::

## eventMakeLast <Badge type="warning" text="🚫TavernHelper" />

让 `listener` 监听 `event_type`, 当事件发生时自动在最后运行 `listener`. 如果 `listener` 已经在监听 `event_type`, 则调用本函数会将 `listener` 调整为最后运行.

当 `eventMakeLast` 所在的前端界面/脚本关闭时, 监听将会自动卸载.

```ts
function eventMakeLast<T extends EventType>(
  event_type: T,
  listener: ListenerType[T],
): void;
```

### 参数

#### `event_type`

- **类型**: [`EventType`](./监听和发送事件#事件列表)
- **描述**: 要监听的事件

#### `listener`

- **类型**: `Function`
- **描述**: 要注册/调整到最后运行的函数

### 示例

```ts
eventMakeLast(要监听的事件, 要注册的函数);
```

## eventMakeFirst <Badge type="warning" text="🚫TavernHelper" />

让 `listener` 监听 `event_type`, 当事件发生时自动在最先运行 `listener`; 如果 `listener` 已经在监听 `event_type`, 则调用本函数会将 `listener` 调整为最先运行.

当 `eventMakeFirst` 所在的前端界面/脚本关闭时, 监听将会自动卸载.

```ts
function eventMakeFirst<T extends EventType>(
  event_type: T,
  listener: ListenerType[T],
): void;
```

### 参数

#### `event_type`

- **类型**: [`EventType`](./监听和发送事件#事件列表)
- **描述**: 要监听的事件

#### `listener`

- **类型**: `Function`
- **描述**: 要注册/调整到最先运行的函数

### 示例

```ts
eventMakeFirst(要监听的事件, 要注册的函数);
```

## eventOnce <Badge type="warning" text="🚫TavernHelper" />

让 `listener` 仅监听下一次 `event_type`, 当该次事件发生时运行 `listener`, 此后取消监听; 如果 `listener` 已经在监听 `event_type`, 则调用本函数不会有任何效果.

当 `eventOnce` 所在的前端界面/脚本关闭时, 监听将会自动卸载.

```ts
function eventOnce<T extends EventType>(
  event_type: T,
  listener: ListenerType[T],
): void;
```

### 参数

#### `event_type`

- **类型**: [`EventType`](./监听和发送事件#事件列表)
- **描述**: 要监听的事件

#### `listener`

- **类型**: `Function`
- **描述**: 要注册的函数

### 示例

```ts
eventOnce(要监听的事件, 要注册的函数);
```

## eventEmit <Badge type="warning" text="🚫TavernHelper" />

发送 `event_type` 事件, 同时可以发送一些数据 `data`.

所有正在监听 `event_type` 消息频道的都会收到该消息并接收到 `data`.

```ts
function eventEmit<T extends EventType>(
  event_type: T,
  ...data: Parameters<ListenerType[T]>
): Promise<void>;
```

### 参数

#### `event_type`

- **类型**: [`EventType`](./监听和发送事件#事件列表)
- **描述**: 要发送的事件

#### `data`

- **类型**: `any[]`
- **描述**: 要随着事件发送的数据

### 示例

:::code-group

```ts [发送"角色阶段更新完成"事件]
// 发送 "角色阶段更新完成" 事件, 所有监听该事件的 `listener` 都会被运行
eventEmit("角色阶段更新完成");
```

```ts [发送"存档"事件]
// 发送 "存档" 事件, 并等待所有 `listener` (也许是负责存档的函数) 执行完毕后才继续
await eventEmit("存档");
```

```ts [发送时携带数据]
// 发送时携带数据 ["你好", 0]
eventEmit("事件", "你好", 0);
```

:::

### /STScript 命令

我们还提供了 /STScript 命令 `/event-emit`, 允许你通过在快速回复按钮中发送事件来触发脚本.

:::code-group

```plaintext [快速回复部分]
/event-emit event="随便什么名字" data="这是一个有空格的 数据" data={{user}}
```

```ts [代码部分]
eventOn("随便什么名字", (data1, data2) => { console.info(data1, data2); });
```

:::

当我们按下该快速回复的按钮后, 正在监听 "随便什么名字" 消息频道的代码将会获得 `data` 并开始执行.

:::tip
当然, 更建议你直接使用[酒馆助手脚本按钮](/guide/基本用法/脚本库.md)来触发脚本.
:::

## eventEmitAndWait <Badge type="warning" text="🚫TavernHelper" />

携带 `data` 而发送 `event_type` 事件并等待事件处理结束.

```ts
function eventEmitAndWait<T extends EventType>(
  event_type: T,
  ...data: Parameters<ListenerType[T]>
): void;
```

### 参数

#### `event_type`

- **类型**: [`EventType`](./监听和发送事件#事件列表)
- **描述**: 要发送的事件

#### `data`

- **类型**: `any[]`
- **描述**: 要随着事件发送的数据

## eventRemoveListener <Badge type="warning" text="🚫TavernHelper" />

让 `listener` 取消对 `event_type` 的监听; 如果 `listener` 没有监听 `event_type`, 则调用本函数不会有任何效果.

前端界面/脚本关闭时会自动卸载所有的事件监听, 你不必手动调用 `eventRemoveListener` 来移除.

```ts
function eventRemoveListener<T extends EventType>(
  event_type: T,
  listener: ListenerType[T],
): void;
```

### 参数

#### `event_type`

- **类型**: [`EventType`](./监听和发送事件#事件列表)
- **描述**: 要发送的事件

#### `listener`

- **类型**: `Function`
- **描述**: 要取消注册的函数

### 示例

```ts
eventRemoveListener(要取消监听的事件, 要取消注册的函数);
```

## eventClearEvent <Badge type="warning" text="🚫TavernHelper" />

取消本 iframe 中对 `event_type` 的所有监听.

前端界面/脚本关闭时会自动卸载所有的事件监听, 你不必手动调用 `eventClearEvent` 来移除.

```ts
function eventClearEvent(event_type: EventType): void;
```

### 参数

#### `event_type`

- **类型**: [`EventType`](./监听和发送事件#事件列表)
- **描述**: 要取消监听的事件

## eventClearListener <Badge type="warning" text="🚫TavernHelper" />

取消本 iframe 中 `listener` 的所有监听.

前端界面/脚本关闭时会自动卸载所有的事件监听, 你不必手动调用 `eventClearListener` 来移除.

```ts
function eventClearListener(listener: Function): void;
```

### 参数

#### `listener`

- **类型**: `Function`
- **描述**: 要取消注册的函数

## eventClearAll <Badge type="warning" text="🚫TavernHelper" />

取消本 iframe 中对所有事件的所有监听.

前端界面/脚本关闭时会自动卸载所有的事件监听, 你不必手动调用 `eventClearAll` 来移除.

```ts
function eventClearAll(): void;
```
