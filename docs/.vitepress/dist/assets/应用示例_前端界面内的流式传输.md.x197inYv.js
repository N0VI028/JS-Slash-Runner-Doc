import{_ as a,C as d,c as o,o as p,ao as n,j as i,a as s,G as l,w as r}from"./chunks/framework.DuPVQoDA.js";const v=JSON.parse('{"title":"前端界面内的流式传输","description":"","frontmatter":{},"headers":[],"relativePath":"应用示例/前端界面内的流式传输.md","filePath":"应用示例/前端界面内的流式传输.md","lastUpdated":1740044871000}'),u={name:"应用示例/前端界面内的流式传输.md"};function m(k,e,E,f,g,h){const t=d("VPNolebaseInlineLinkPreview");return p(),o("div",null,[e[30]||(e[30]=n('<h1 id="前端界面内的流式传输" tabindex="-1">前端界面内的流式传输 <a class="header-anchor" href="#前端界面内的流式传输" aria-label="Permalink to &quot;前端界面内的流式传输&quot;">​</a></h1><p>目前前端卡最大的问题是依赖于由正则替换得来的消息楼层 iframe 代码块；而流式传输过程中，每次收到新的流式文本，正则替换都会重新应用，这就导致消息楼层 iframe 只能一直是代码块，而直到文本输出完成才能渲染。 以下汇总了能想到的流式传输前端卡思路。</p><h2 id="思路1-自制前端界面负责流式传输文本处理-推荐" tabindex="-1">思路1: 自制前端界面负责流式传输文本处理（推荐） <a class="header-anchor" href="#思路1-自制前端界面负责流式传输文本处理-推荐" aria-label="Permalink to &quot;思路1: 自制前端界面负责流式传输文本处理（推荐）&quot;">​</a></h2><h3 id="方法1-不再依靠酒馆发送键-在消息楼层-iframe-中自行设计发送功能-简单" tabindex="-1">方法1: 不再依靠酒馆发送键，在消息楼层 iframe 中自行设计发送功能（简单） <a class="header-anchor" href="#方法1-不再依靠酒馆发送键-在消息楼层-iframe-中自行设计发送功能-简单" aria-label="Permalink to &quot;方法1: 不再依靠酒馆发送键，在消息楼层 iframe 中自行设计发送功能（简单）&quot;">​</a></h3><p>一个简单的示例是用消息楼层 iframe 制作手机微信界面，在界面中专门有一个发送键，点击后对话的角色将会直接回复消息</p>',5)),i("ul",null,[i("li",null,[e[1]||(e[1]=s("我的框架：")),l(t,{href:"https://discord.com/channels/1134557553011998840/1296494001406345318/1328423793701683323",target:"_blank",rel:"noreferrer"},{default:r(()=>e[0]||(e[0]=[s("Discord帖子")])),_:1})]),i("li",null,[e[3]||(e[3]=s("他人的原创实战例子：")),l(t,{href:"https://discord.com/channels/1134557553011998840/1326003324088090704/1336653204598816848",target:"_blank",rel:"noreferrer"},{default:r(()=>e[2]||(e[2]=[s("Discord帖子")])),_:1})])]),e[31]||(e[31]=i("p",null,"也就是说,",-1)),i("ul",null,[e[12]||(e[12]=i("li",null,"玩家只在顶楼的消息楼层 iframe 内进行游玩，不再生成新的楼层；",-1)),i("li",null,[e[6]||(e[6]=s("对于玩家的输入，我们通过前端助手的 ")),l(t,{href:"./../功能详情/请求生成.html#generate"},{default:r(()=>e[4]||(e[4]=[i("code",null,"generate",-1)])),_:1}),e[7]||(e[7]=s("、")),l(t,{href:"./../功能详情/请求生成.html#generateraw"},{default:r(()=>e[5]||(e[5]=[i("code",null,"generateRaw",-1)])),_:1}),e[8]||(e[8]=s(" 命令自行要求 ai 回复；"))]),i("li",null,[e[10]||(e[10]=s("为了让消息记录下来，我们用 ")),l(t,{href:"./../功能详情/楼层消息.html#setchatmessage"},{default:r(()=>e[9]||(e[9]=[i("code",null,"setChatMessage",-1)])),_:1}),e[11]||(e[11]=s(" 将它保存到消息文件中（或自制存档机制？）。"))])]),e[32]||(e[32]=i("h3",{id:"方法2-不再依靠酒馆显示-用全局脚本-iframe-获取流式传输文本并生成界面-可能更自由",tabindex:"-1"},[s("方法2: 不再依靠酒馆显示，用全局脚本 iframe 获取流式传输文本并生成界面（可能更自由） "),i("a",{class:"header-anchor",href:"#方法2-不再依靠酒馆显示-用全局脚本-iframe-获取流式传输文本并生成界面-可能更自由","aria-label":'Permalink to "方法2: 不再依靠酒馆显示，用全局脚本 iframe 获取流式传输文本并生成界面（可能更自由）"'},"​")],-1)),e[33]||(e[33]=i("p",null,"既然酒馆的流式传输在显示上有问题，我们不再依赖于酒馆的显示，不再是用正则替换一个消息楼层 iframe 出来用于渲染。",-1)),i("p",null,[e[15]||(e[15]=s("作为替代，我们使用 ")),l(t,{href:"./../基本用法/全局脚本.html#全局脚本"},{default:r(()=>e[13]||(e[13]=[s("全局脚本 iframe")])),_:1}),e[16]||(e[16]=s(" 来监听流式传输文本：")),l(t,{href:"https://discord.com/channels/1134557553011998840/1330206359362211960",target:"_blank",rel:"noreferrer"},{default:r(()=>e[14]||(e[14]=[s("Discord帖子")])),_:1})]),e[34]||(e[34]=n('<ul><li>监听 <code>tavern_events.MESSAGE_SEND -&gt; message_id</code>，我们可以知道玩家要求酒馆调用 ai 生成；</li><li>监听 <code>tavern_events.STREAM_TOKEN_RECEIVED - &gt; text</code>，我们可以获取流式传输文本；</li><li>监听 <code>tavern_events.MESSAGE_RECEIVED -&gt; message_id</code>，我们可以知道酒馆结束了回复。</li></ul><p>由此，我们完全可以收集到<strong>流式传输文本</strong>，将它发送到一个你自制的前端界面中。</p><p>而为了让那个前端界面显示出来，你可以使用 JQuery。 JQuery 可以访问界面 html 元素，以修改消息楼层的显示文本为例（仅修改本次显示，不会修改实际的消息文件）:</p><div class="language-typescript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`div.mes[mesid = &quot;${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message_id</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}&quot;]`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，window.parent.document).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">find</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`div.mes_text`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`&lt;p&gt;新的文本&lt;/p&gt;`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="思路2-让流式传输出来的文本可读" tabindex="-1">思路2: 让流式传输出来的文本可读 <a class="header-anchor" href="#思路2-让流式传输出来的文本可读" aria-label="Permalink to &quot;思路2: 让流式传输出来的文本可读&quot;">​</a></h2><p>另一种思路是直接舍弃前端助手常见的“正则替换正文，从而让正文变成会被渲染的代码块”。</p><p>作为替代，直接让全局脚本在消息接收完毕时处理变量然后修改消息，在修改消息时直接连同要渲染的代码块一起发送过去。 这样，玩家可以先看文本，等输出完后再看到前端美化结果:</p>',7)),i("ol",null,[e[27]||(e[27]=i("li",null,[s("全局脚本监听 "),i("code",null,"tavern_events.MESSAGE_RECEIVED -> message_id"),s("，获取新消息楼层中的 ai 输出；")],-1)),e[28]||(e[28]=i("li",null,"全局脚本处理消息中的计算；",-1)),i("li",null,[e[19]||(e[19]=s("全局脚本通过 ")),l(t,{href:"./../功能详情/酒馆正则.html#gettavernregexes"},{default:r(()=>e[17]||(e[17]=[i("code",null,"getTavernRegexes",-1)])),_:1}),e[20]||(e[20]=s(" 或 ")),l(t,{href:"./../功能详情/世界书/获取世界书.html#getLorebookEntries"},{default:r(()=>e[18]||(e[18]=[i("code",null,"getLorebookEntries",-1)])),_:1}),e[21]||(e[21]=s(" 等，来得到存储在正则、世界书条目或其他地方的消息楼层 iframe（要渲染的")),e[22]||(e[22]=i("code",null,"<body>",-1)),e[23]||(e[23]=s("代码块）;"))]),e[29]||(e[29]=i("li",null,"全局脚本将之前的计算结果填入到获取到的消息楼层 iframe 中；",-1)),i("li",null,[e[25]||(e[25]=s("全局脚本用 ")),l(t,{href:"./../功能详情/楼层消息.html#setchatmessage"},{default:r(()=>e[24]||(e[24]=[i("code",null,"setChatMessage",-1)])),_:1}),e[26]||(e[26]=s(" 将消息楼层修改为该消息楼层 iframe。"))])])])}const y=a(u,[["render",m]]);export{v as __pageData,y as default};
